// Tool generates JSON document using monster productions.
// * productions are defined for `default`, `users` and `projects` bucket.
// * parallel load can be generated using `-par` switch.
// * `-count` switch specify no. of documents to be generated by each routine.

package main

import "flag"
import "fmt"
import "io/ioutil"
import "log"
import "net/url"
import "os"
import "strings"
import "time"

import "github.com/couchbase/indexing/secondary/dcp"
import parsec "github.com/prataprc/goparsec"
import "github.com/prataprc/monster"
import mcommon "github.com/prataprc/monster/common"

var options struct {
	seed     int      // seed for monster tool
	buckets  []string // buckets to populate
	prods    []string
	bagdir   string
	parallel int // number of parallel routines per bucket
	count    int // number of documents to be generated per routine
	expiry   int // set expiry for the document, in seconds
}

var done = make(chan bool, 16)

func argParse() string {
	var buckets, prods string

	seed := time.Now().UTC().Second()
	flag.IntVar(&options.seed, "seed", seed,
		"seed for monster tool")
	flag.StringVar(&buckets, "buckets", "default",
		"comma separated list of buckets")
	flag.StringVar(&prods, "prods", "users.prod",
		"comma separated list of production files for each bucket")
	flag.StringVar(&options.bagdir, "bagdir", "",
		"bagdirectory for production files.")
	flag.IntVar(&options.parallel, "par", 1,
		"number of parallel routines per bucket")
	flag.IntVar(&options.count, "count", 0,
		"number of documents to be generated per routine")
	flag.IntVar(&options.expiry, "expiry", 0,
		"expiry duration for a document (TTL)")

	flag.Parse()

	options.buckets = strings.Split(buckets, ",")
	options.prods = strings.Split(prods, ",")

	// the last production file is used for remaining bucket.
	if pn, bn := len(options.prods), len(options.buckets); pn != bn {
		lastprod := options.prods[pn-1]
		for i := pn; i < bn; i++ {
			options.prods = append(options.prods, lastprod)
		}
	}

	args := flag.Args()
	if len(args) < 1 || options.bagdir == "" {
		usage()
		os.Exit(1)
	}
	return args[0]
}

func usage() {
	fmt.Fprintf(os.Stderr, "Usage : %s [OPTIONS] <cluster-addr> \n", os.Args[0])
	flag.PrintDefaults()
}

func main() {
	cluster := argParse()
	if !strings.HasPrefix(cluster, "http://") {
		cluster = "http://" + cluster
	}

	n := 0
	for i, bucket := range options.buckets {
		prodfile := options.prods[i]
		n += loadBucket(cluster, bucket, prodfile, options.count)
	}
	for n > 0 {
		<-done
		n--
	}
}

func loadBucket(cluster, bucket, prodfile string, count int) int {
	u, err := url.Parse(cluster)
	mf(err, "parse")

	c, err := couchbase.Connect(u.String())
	mf(err, "connect - "+u.String())

	p, err := c.GetPool("default")
	mf(err, "pool")

	bs := make([]*couchbase.Bucket, 0, options.parallel)
	for i := 0; i < options.parallel; i++ {
		b, err := p.GetBucket(bucket)
		mf(err, "bucket")
		bs = append(bs, b)
		go genDocuments(b, prodfile, i+1, options.count)
	}
	return options.parallel
}

func genDocuments(b *couchbase.Bucket, prodfile string, idx, n int) {
	// compile
	text, err := ioutil.ReadFile(prodfile)
	if err != nil {
		log.Fatal(err)
	}
	root := compile(parsec.NewScanner(text))
	scope := root.(mcommon.Scope)
	nterms := scope["_nonterminals"].(mcommon.NTForms)
	scope = monster.BuildContext(scope, uint64(options.seed), options.bagdir)
	scope["_prodfile"] = prodfile
	// evaluate
	for i := 0; i < options.count; i++ {
		doc := evaluate("root", scope, nterms["s"]).(string)
		key := fmt.Sprintf("%s-%v-%v", b.Name, idx, i+1)
		err = b.SetRaw(key, options.expiry, []byte(doc))
		if err != nil {
			fmt.Printf("%T %v\n", err, err)
		}
		mf(err, "error setting document")
	}
	fmt.Printf("routine %v generated %v documents for %q\n", idx, n, b.Name)
	done <- true
}

func compile(s parsec.Scanner) parsec.ParsecNode {
	defer func() {
		if r := recover(); r != nil {
			log.Printf("%v at %v", r, s.GetCursor())
		}
	}()
	root, _ := monster.Y(s)
	return root
}

func evaluate(name string, scope mcommon.Scope, forms []*mcommon.Form) interface{} {
	defer func() {
		if r := recover(); r != nil {
			log.Printf("%v", r)
		}
	}()
	scope = scope.ApplyGlobalForms()
	return monster.EvalForms(name, scope, forms)
}

func mf(err error, msg string) {
	if err != nil {
		log.Fatalf("%v: %v", msg, err)
	}
}
