// Code generated by protoc-gen-go. DO NOT EDIT.
// source: index.proto

package protobuf

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// IndexDefn will be in one of the following state
type IndexState int32

const (
	// Create index accepted, replicated and response sent back to admin
	// console.
	IndexState_IndexInitial IndexState = 1
	// Index DDL replicated, and then communicated to participating indexers.
	IndexState_IndexPending IndexState = 2
	// Initial-load request received from admin console, DDL replicated,
	// loading status communicated with participating indexer and
	// initial-load request is posted to projector.
	IndexState_IndexLoading IndexState = 3
	// Initial-loading is completed for this index from all partiticipating
	// indexers, DDL replicated, and finaly initial-load stream is shutdown.
	IndexState_IndexActive IndexState = 4
	// Delete index request is received, replicated and then communicated with
	// each participating indexer nodes.
	IndexState_IndexDeleted IndexState = 5
)

var IndexState_name = map[int32]string{
	1: "IndexInitial",
	2: "IndexPending",
	3: "IndexLoading",
	4: "IndexActive",
	5: "IndexDeleted",
}

var IndexState_value = map[string]int32{
	"IndexInitial": 1,
	"IndexPending": 2,
	"IndexLoading": 3,
	"IndexActive":  4,
	"IndexDeleted": 5,
}

func (x IndexState) Enum() *IndexState {
	p := new(IndexState)
	*p = x
	return p
}

func (x IndexState) String() string {
	return proto.EnumName(IndexState_name, int32(x))
}

func (x *IndexState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(IndexState_value, data, "IndexState")
	if err != nil {
		return err
	}
	*x = IndexState(value)
	return nil
}

func (IndexState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f750e0f7889345b5, []int{0}
}

// List of possible index storage algorithms.
type StorageType int32

const (
	StorageType_forestdb         StorageType = 1
	StorageType_memdb            StorageType = 2
	StorageType_memory_optimized StorageType = 3
)

var StorageType_name = map[int32]string{
	1: "forestdb",
	2: "memdb",
	3: "memory_optimized",
}

var StorageType_value = map[string]int32{
	"forestdb":         1,
	"memdb":            2,
	"memory_optimized": 3,
}

func (x StorageType) Enum() *StorageType {
	p := new(StorageType)
	*p = x
	return p
}

func (x StorageType) String() string {
	return proto.EnumName(StorageType_name, int32(x))
}

func (x *StorageType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(StorageType_value, data, "StorageType")
	if err != nil {
		return err
	}
	*x = StorageType(value)
	return nil
}

func (StorageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f750e0f7889345b5, []int{1}
}

// Type of expression used to evaluate document.
type ExprType int32

const (
	ExprType_JAVASCRIPT ExprType = 1
	ExprType_N1QL       ExprType = 2
)

var ExprType_name = map[int32]string{
	1: "JAVASCRIPT",
	2: "N1QL",
}

var ExprType_value = map[string]int32{
	"JAVASCRIPT": 1,
	"N1QL":       2,
}

func (x ExprType) Enum() *ExprType {
	p := new(ExprType)
	*p = x
	return p
}

func (x ExprType) String() string {
	return proto.EnumName(ExprType_name, int32(x))
}

func (x *ExprType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ExprType_value, data, "ExprType")
	if err != nil {
		return err
	}
	*x = ExprType(value)
	return nil
}

func (ExprType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f750e0f7889345b5, []int{2}
}

// Type of topology, including paritition type to be used for the index.
type PartitionScheme int32

const (
	PartitionScheme_TEST   PartitionScheme = 1
	PartitionScheme_SINGLE PartitionScheme = 2
	PartitionScheme_KEY    PartitionScheme = 3
	PartitionScheme_HASH   PartitionScheme = 4
	PartitionScheme_RANGE  PartitionScheme = 5
)

var PartitionScheme_name = map[int32]string{
	1: "TEST",
	2: "SINGLE",
	3: "KEY",
	4: "HASH",
	5: "RANGE",
}

var PartitionScheme_value = map[string]int32{
	"TEST":   1,
	"SINGLE": 2,
	"KEY":    3,
	"HASH":   4,
	"RANGE":  5,
}

func (x PartitionScheme) Enum() *PartitionScheme {
	p := new(PartitionScheme)
	*p = x
	return p
}

func (x PartitionScheme) String() string {
	return proto.EnumName(PartitionScheme_name, int32(x))
}

func (x *PartitionScheme) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PartitionScheme_value, data, "PartitionScheme")
	if err != nil {
		return err
	}
	*x = PartitionScheme(value)
	return nil
}

func (PartitionScheme) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f750e0f7889345b5, []int{3}
}

// Type of Hash scheme for partitioned index
type HashScheme int32

const (
	HashScheme_CRC32 HashScheme = 0
)

var HashScheme_name = map[int32]string{
	0: "CRC32",
}

var HashScheme_value = map[string]int32{
	"CRC32": 0,
}

func (x HashScheme) Enum() *HashScheme {
	p := new(HashScheme)
	*p = x
	return p
}

func (x HashScheme) String() string {
	return proto.EnumName(HashScheme_name, int32(x))
}

func (x *HashScheme) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(HashScheme_value, data, "HashScheme")
	if err != nil {
		return err
	}
	*x = HashScheme(value)
	return nil
}

func (HashScheme) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f750e0f7889345b5, []int{4}
}

// IndexInst message as payload between co-ordinator, projector, indexer.
type IndexInst struct {
	InstId               *uint64          `protobuf:"varint,1,req,name=instId" json:"instId,omitempty"`
	State                *IndexState      `protobuf:"varint,2,req,name=state,enum=protobuf.IndexState" json:"state,omitempty"`
	Definition           *IndexDefn       `protobuf:"bytes,3,req,name=definition" json:"definition,omitempty"`
	Tp                   *TestPartition   `protobuf:"bytes,4,opt,name=tp" json:"tp,omitempty"`
	SinglePartn          *SinglePartition `protobuf:"bytes,5,opt,name=singlePartn" json:"singlePartn,omitempty"`
	KeyPartn             *KeyPartition    `protobuf:"bytes,6,opt,name=keyPartn" json:"keyPartn,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *IndexInst) Reset()         { *m = IndexInst{} }
func (m *IndexInst) String() string { return proto.CompactTextString(m) }
func (*IndexInst) ProtoMessage()    {}
func (*IndexInst) Descriptor() ([]byte, []int) {
	return fileDescriptor_f750e0f7889345b5, []int{0}
}

func (m *IndexInst) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IndexInst.Unmarshal(m, b)
}
func (m *IndexInst) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IndexInst.Marshal(b, m, deterministic)
}
func (m *IndexInst) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexInst.Merge(m, src)
}
func (m *IndexInst) XXX_Size() int {
	return xxx_messageInfo_IndexInst.Size(m)
}
func (m *IndexInst) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexInst.DiscardUnknown(m)
}

var xxx_messageInfo_IndexInst proto.InternalMessageInfo

func (m *IndexInst) GetInstId() uint64 {
	if m != nil && m.InstId != nil {
		return *m.InstId
	}
	return 0
}

func (m *IndexInst) GetState() IndexState {
	if m != nil && m.State != nil {
		return *m.State
	}
	return IndexState_IndexInitial
}

func (m *IndexInst) GetDefinition() *IndexDefn {
	if m != nil {
		return m.Definition
	}
	return nil
}

func (m *IndexInst) GetTp() *TestPartition {
	if m != nil {
		return m.Tp
	}
	return nil
}

func (m *IndexInst) GetSinglePartn() *SinglePartition {
	if m != nil {
		return m.SinglePartn
	}
	return nil
}

func (m *IndexInst) GetKeyPartn() *KeyPartition {
	if m != nil {
		return m.KeyPartn
	}
	return nil
}

// Index DDL from create index statement.
type IndexDefn struct {
	DefnID               *uint64          `protobuf:"varint,1,req,name=defnID" json:"defnID,omitempty"`
	Bucket               *string          `protobuf:"bytes,2,req,name=bucket" json:"bucket,omitempty"`
	IsPrimary            *bool            `protobuf:"varint,3,req,name=isPrimary" json:"isPrimary,omitempty"`
	Name                 *string          `protobuf:"bytes,4,req,name=name" json:"name,omitempty"`
	Using                *StorageType     `protobuf:"varint,5,req,name=using,enum=protobuf.StorageType" json:"using,omitempty"`
	ExprType             *ExprType        `protobuf:"varint,6,req,name=exprType,enum=protobuf.ExprType" json:"exprType,omitempty"`
	SecExpressions       []string         `protobuf:"bytes,7,rep,name=secExpressions" json:"secExpressions,omitempty"`
	PartitionScheme      *PartitionScheme `protobuf:"varint,8,opt,name=partitionScheme,enum=protobuf.PartitionScheme" json:"partitionScheme,omitempty"`
	PartnExpression      *string          `protobuf:"bytes,9,opt,name=partnExpression" json:"partnExpression,omitempty"`
	WhereExpression      *string          `protobuf:"bytes,10,opt,name=whereExpression" json:"whereExpression,omitempty"`
	PartnExpressions     []string         `protobuf:"bytes,11,rep,name=partnExpressions" json:"partnExpressions,omitempty"`
	RetainDeletedXATTR   *bool            `protobuf:"varint,12,opt,name=retainDeletedXATTR" json:"retainDeletedXATTR,omitempty"`
	HashScheme           *HashScheme      `protobuf:"varint,13,opt,name=hashScheme,enum=protobuf.HashScheme" json:"hashScheme,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *IndexDefn) Reset()         { *m = IndexDefn{} }
func (m *IndexDefn) String() string { return proto.CompactTextString(m) }
func (*IndexDefn) ProtoMessage()    {}
func (*IndexDefn) Descriptor() ([]byte, []int) {
	return fileDescriptor_f750e0f7889345b5, []int{1}
}

func (m *IndexDefn) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IndexDefn.Unmarshal(m, b)
}
func (m *IndexDefn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IndexDefn.Marshal(b, m, deterministic)
}
func (m *IndexDefn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexDefn.Merge(m, src)
}
func (m *IndexDefn) XXX_Size() int {
	return xxx_messageInfo_IndexDefn.Size(m)
}
func (m *IndexDefn) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexDefn.DiscardUnknown(m)
}

var xxx_messageInfo_IndexDefn proto.InternalMessageInfo

func (m *IndexDefn) GetDefnID() uint64 {
	if m != nil && m.DefnID != nil {
		return *m.DefnID
	}
	return 0
}

func (m *IndexDefn) GetBucket() string {
	if m != nil && m.Bucket != nil {
		return *m.Bucket
	}
	return ""
}

func (m *IndexDefn) GetIsPrimary() bool {
	if m != nil && m.IsPrimary != nil {
		return *m.IsPrimary
	}
	return false
}

func (m *IndexDefn) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *IndexDefn) GetUsing() StorageType {
	if m != nil && m.Using != nil {
		return *m.Using
	}
	return StorageType_forestdb
}

func (m *IndexDefn) GetExprType() ExprType {
	if m != nil && m.ExprType != nil {
		return *m.ExprType
	}
	return ExprType_JAVASCRIPT
}

func (m *IndexDefn) GetSecExpressions() []string {
	if m != nil {
		return m.SecExpressions
	}
	return nil
}

func (m *IndexDefn) GetPartitionScheme() PartitionScheme {
	if m != nil && m.PartitionScheme != nil {
		return *m.PartitionScheme
	}
	return PartitionScheme_TEST
}

func (m *IndexDefn) GetPartnExpression() string {
	if m != nil && m.PartnExpression != nil {
		return *m.PartnExpression
	}
	return ""
}

func (m *IndexDefn) GetWhereExpression() string {
	if m != nil && m.WhereExpression != nil {
		return *m.WhereExpression
	}
	return ""
}

func (m *IndexDefn) GetPartnExpressions() []string {
	if m != nil {
		return m.PartnExpressions
	}
	return nil
}

func (m *IndexDefn) GetRetainDeletedXATTR() bool {
	if m != nil && m.RetainDeletedXATTR != nil {
		return *m.RetainDeletedXATTR
	}
	return false
}

func (m *IndexDefn) GetHashScheme() HashScheme {
	if m != nil && m.HashScheme != nil {
		return *m.HashScheme
	}
	return HashScheme_CRC32
}

func init() {
	proto.RegisterEnum("protobuf.IndexState", IndexState_name, IndexState_value)
	proto.RegisterEnum("protobuf.StorageType", StorageType_name, StorageType_value)
	proto.RegisterEnum("protobuf.ExprType", ExprType_name, ExprType_value)
	proto.RegisterEnum("protobuf.PartitionScheme", PartitionScheme_name, PartitionScheme_value)
	proto.RegisterEnum("protobuf.HashScheme", HashScheme_name, HashScheme_value)
	proto.RegisterType((*IndexInst)(nil), "protobuf.IndexInst")
	proto.RegisterType((*IndexDefn)(nil), "protobuf.IndexDefn")
}

func init() { proto.RegisterFile("index.proto", fileDescriptor_f750e0f7889345b5) }

var fileDescriptor_f750e0f7889345b5 = []byte{
	// 581 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x5c, 0x92, 0x51, 0x6f, 0x9b, 0x3e,
	0x14, 0xc5, 0xff, 0x10, 0x48, 0xe1, 0x92, 0x3f, 0xf5, 0xbc, 0xae, 0xf5, 0xfa, 0x84, 0xda, 0x4a,
	0x43, 0x79, 0x88, 0xb4, 0xec, 0x75, 0x2f, 0x51, 0x1b, 0xb5, 0x59, 0xab, 0x2a, 0x0b, 0xd1, 0xb4,
	0x3d, 0x55, 0x24, 0xdc, 0x34, 0x56, 0x8b, 0x41, 0xd8, 0xdd, 0x9a, 0x7d, 0xe2, 0x7d, 0x82, 0x3d,
	0x4f, 0x18, 0x06, 0xac, 0x4f, 0xe0, 0x73, 0x7e, 0xd7, 0x3e, 0xf7, 0xda, 0xe0, 0x71, 0x91, 0xe0,
	0xf3, 0x28, 0x2f, 0x32, 0x95, 0x51, 0x47, 0x7f, 0x56, 0x4f, 0x9b, 0x63, 0x3f, 0x8f, 0x0b, 0x25,
	0xee, 0x54, 0x5e, 0x39, 0xc7, 0xb4, 0x5a, 0x4b, 0x2e, 0xee, 0x1f, 0xb1, 0xd6, 0xf6, 0x2b, 0xed,
	0x01, 0x77, 0x95, 0x70, 0xf2, 0xcb, 0x00, 0x77, 0x56, 0x6e, 0x37, 0x13, 0x52, 0x51, 0x1f, 0xfa,
	0x5c, 0x48, 0x35, 0x4b, 0x98, 0x11, 0x98, 0xa1, 0x45, 0x4f, 0xc1, 0x96, 0x2a, 0x56, 0xc8, 0xcc,
	0xc0, 0x0c, 0xfd, 0xf1, 0xc1, 0xe8, 0xef, 0x61, 0x23, 0x5d, 0x13, 0x95, 0x1e, 0x7d, 0x07, 0x90,
	0xe0, 0x86, 0x0b, 0xae, 0x78, 0x26, 0x58, 0x2f, 0x30, 0x43, 0x6f, 0xfc, 0xfa, 0x05, 0x79, 0x81,
	0x1b, 0x41, 0x4f, 0xc1, 0x54, 0x39, 0xb3, 0x02, 0x23, 0xf4, 0xc6, 0x47, 0x2d, 0xb0, 0x44, 0xa9,
	0xe6, 0x71, 0xa1, 0x74, 0x3d, 0x1d, 0x81, 0x57, 0x25, 0x2e, 0x25, 0xc1, 0x6c, 0x4d, 0xbf, 0x6d,
	0xe9, 0xa8, 0x31, 0x2b, 0x3e, 0x04, 0xe7, 0x01, 0x77, 0x15, 0xdc, 0xd7, 0xf0, 0x61, 0x0b, 0x5f,
	0x57, 0x8e, 0x26, 0x4f, 0x7e, 0x9b, 0x75, 0xab, 0x3a, 0x8c, 0x0f, 0xfd, 0x04, 0x37, 0x62, 0x76,
	0x51, 0xb7, 0xea, 0x43, 0x7f, 0xf5, 0xb4, 0x7e, 0x40, 0xa5, 0x7b, 0x75, 0xe9, 0x2b, 0x70, 0xb9,
	0x9c, 0x17, 0x3c, 0x8d, 0x8b, 0x9d, 0x6e, 0xca, 0xa1, 0x03, 0xb0, 0x44, 0x9c, 0x22, 0xb3, 0x34,
	0x70, 0x06, 0xf6, 0x53, 0x99, 0x94, 0xd9, 0x7a, 0x36, 0x6f, 0x3a, 0x11, 0x55, 0x56, 0xc4, 0xf7,
	0xb8, 0xdc, 0xe5, 0x48, 0xcf, 0xc0, 0xc1, 0xe7, 0xbc, 0x28, 0xff, 0x59, 0x5f, 0x83, 0xb4, 0x05,
	0xa7, 0xb5, 0x43, 0x0f, 0xc1, 0x97, 0xb8, 0x2e, 0x97, 0x28, 0x25, 0xcf, 0x84, 0x64, 0x7b, 0x41,
	0x2f, 0x74, 0xe9, 0x18, 0xf4, 0x85, 0xe9, 0xfc, 0xd1, 0x7a, 0x8b, 0x29, 0x32, 0x27, 0x30, 0x42,
	0xbf, 0x3b, 0x90, 0xf9, 0xbf, 0x00, 0x3d, 0xaa, 0x6a, 0x44, 0xbb, 0x1b, 0x73, 0x03, 0x23, 0x74,
	0x4b, 0xe3, 0xc7, 0x16, 0x0b, 0xec, 0x18, 0xa0, 0x0d, 0x06, 0xe4, 0x45, 0x85, 0x64, 0x9e, 0x3e,
	0xff, 0x18, 0x68, 0x81, 0x2a, 0xe6, 0xe2, 0x02, 0x1f, 0x51, 0x61, 0xf2, 0x75, 0xb2, 0x5c, 0x2e,
	0xd8, 0x20, 0x30, 0x42, 0x87, 0x86, 0x00, 0xdb, 0x58, 0x6e, 0xeb, 0x58, 0xff, 0xeb, 0x58, 0x9d,
	0x07, 0x72, 0xd5, 0x78, 0x43, 0x04, 0xe8, 0x3c, 0x17, 0x02, 0x83, 0xfa, 0xc1, 0x71, 0xc5, 0xe3,
	0x47, 0x62, 0x34, 0xca, 0x1c, 0x45, 0xc2, 0xc5, 0x3d, 0x31, 0x1b, 0xe5, 0x26, 0x8b, 0xb5, 0xd2,
	0xa3, 0xfb, 0xe0, 0x69, 0x65, 0xb2, 0x56, 0xfc, 0x3b, 0x12, 0xab, 0x41, 0xea, 0x64, 0xc4, 0x1e,
	0x7e, 0x04, 0xaf, 0x3b, 0xf9, 0x01, 0x38, 0x9b, 0xac, 0x40, 0xa9, 0x92, 0x15, 0x31, 0xa8, 0x0b,
	0x76, 0x8a, 0x69, 0xb2, 0x22, 0x26, 0x3d, 0x00, 0x92, 0x62, 0x9a, 0x15, 0xbb, 0xbb, 0x2c, 0x57,
	0x3c, 0xe5, 0x3f, 0x31, 0x21, 0xbd, 0xe1, 0x19, 0x38, 0xcd, 0x75, 0xf8, 0x00, 0x9f, 0x26, 0x5f,
	0x26, 0xd1, 0xf9, 0x62, 0x36, 0x5f, 0x12, 0x83, 0x3a, 0x60, 0xdd, 0xbe, 0xff, 0x7c, 0x43, 0xcc,
	0xe1, 0x14, 0xf6, 0x5f, 0xce, 0xdb, 0x01, 0x6b, 0x39, 0x8d, 0x4a, 0x0c, 0xa0, 0x1f, 0xcd, 0x6e,
	0x2f, 0x6f, 0xa6, 0xc4, 0xa4, 0x7b, 0xd0, 0xbb, 0x9e, 0x7e, 0x23, 0xbd, 0xd2, 0xbe, 0x9a, 0x44,
	0x57, 0xc4, 0x2a, 0x23, 0x2c, 0x26, 0xb7, 0x97, 0x53, 0x62, 0x0f, 0x8f, 0x00, 0xda, 0xf9, 0x94,
	0xc6, 0xf9, 0xe2, 0xfc, 0xc3, 0x98, 0xfc, 0xf7, 0x27, 0x00, 0x00, 0xff, 0xff, 0x57, 0xf1, 0x36,
	0xa9, 0xdb, 0x03, 0x00, 0x00,
}
