package collections

import (
	"fmt"
	"log"
	"testing"
)

// Map of strings to randomly generated uint32 values
var (
	keyCIDMap = map[string]uint32{
		"Hello":        0x00,
		"Couchbase":    0x99,
		"Collections":  0x12234,
		"GSI":          0x576843,
		"FTS":          0x7685346,
		"Query":        0x1712,
		"Analytics":    0x776,
		"ns_server":    0x65645,
		"streams":      0x4321847,
		"dcp":          0x8756,
		"projector":    0x489324,
		"indexer":      0x64889,
		"gsiclient":    0x7981,
		"MAINT_STREAM": 0xfffffff7,
		"INIT_STREAM":  0x80,
		"KV":           0xffffffff,
	}

	expectedEncoding = map[string][]byte{
		"Hello":        []byte{0x00, 0x48, 0x65, 0x6c, 0x6c, 0x6f},
		"Couchbase":    []byte{0x99, 0x01, 0x43, 0x6f, 0x75, 0x63, 0x68, 0x62, 0x61, 0x73, 0x65},
		"Collections":  []byte{0xb4, 0xc4, 0x04, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73},
		"GSI":          []byte{0xc3, 0xd0, 0xdd, 0x02, 0x47, 0x53, 0x49},
		"FTS":          []byte{0xc6, 0xa6, 0xa1, 0x3b, 0x46, 0x54, 0x53},
		"Query":        []byte{0x92, 0x2e, 0x51, 0x75, 0x65, 0x72, 0x79},
		"Analytics":    []byte{0xf6, 0x0e, 0x41, 0x6e, 0x61, 0x6c, 0x79, 0x74, 0x69, 0x63, 0x73},
		"ns_server":    []byte{0xc5, 0xac, 0x19, 0x6e, 0x73, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72},
		"streams":      []byte{0xc7, 0xb0, 0xc8, 0x21, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x73},
		"dcp":          []byte{0xd6, 0x8e, 0x02, 0x64, 0x63, 0x70},
		"projector":    []byte{0xa4, 0xa6, 0xa2, 0x02, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x6f, 0x72},
		"indexer":      []byte{0x89, 0x91, 0x19, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x72},
		"gsiclient":    []byte{0x81, 0xf3, 0x01, 0x67, 0x73, 0x69, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74},
		"KV":           []byte{0xff, 0xff, 0xff, 0xff, 0x0f, 0x4b, 0x56},
		"MAINT_STREAM": []byte{0xf7, 0xff, 0xff, 0xff, 0x0f, 0x4d, 0x41, 0x49, 0x4e, 0x54, 0x5f, 0x53, 0x54, 0x52, 0x45, 0x41, 0x4d},
		"INIT_STREAM":  []byte{0x80, 0x01, 0x49, 0x4e, 0x49, 0x54, 0x5f, 0x53, 0x54, 0x52, 0x45, 0x41, 0x4d},
	}
)

func compareByteSlices(act, exp []byte) bool {
	if len(act) != len(exp) {
		return false
	}

	for i, val := range act {
		if val != exp[i] {
			return false
		}
	}
	return true
}

func TestLEB128Encode(t *testing.T) {
	log.Printf("TestLEB128Encode")
	for key, value := range keyCIDMap {
		encValue := PrependLEB128EncKey(([]byte)(key), value)
		if !compareByteSlices(encValue, expectedEncoding[key]) {
			t.Fatalf("Test failed for key: %v, value: %v. Expected encoding: %v, actual: %v", key, value, expectedEncoding[key], encValue)
		}
	}
}

func TestEmptyCollectionID(t *testing.T) {
	log.Printf("TestEmptyCollectionID")
	cid := ""
	if _, err := PrependLEB128EncStrKey(([]byte)("Hello"), cid); err != ErrorEmptyCollectionId {
		t.Fatalf("Expected error: %v, actual error: %v", ErrorEmptyCollectionId, err)
	}
}

func TestInvalidCollectionID(t *testing.T) {
	log.Printf("TestInvalidCollectionID")
	cid := "Hello"
	if _, err := PrependLEB128EncStrKey(([]byte)("Hello"), cid); err == nil {
		t.Fatalf("Expected an error while converting %v to uint32", cid)
	}
}

func TestLEB128Decode(t *testing.T) {
	log.Printf("TestLEB128Decode")
	for key, value := range expectedEncoding {
		decKey, cid := LEB128Dec(value)
		if key != fmt.Sprintf("%s", decKey) || keyCIDMap[key] != (uint32)(cid) {
			t.Fatalf("Decode test failed for key: %v, value: %v. decoded key: %v, cid: %v. Expected CID: %v", key, value, decKey, cid, keyCIDMap[key])
		}
	}
}
